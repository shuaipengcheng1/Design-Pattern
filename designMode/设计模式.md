# 23种设计模式
创建型模式 单例模式(一个对象) 工厂模式(抽象工程模式) 建造者模式 原型模式
结构型模式 适配器模式(类似中间件)
行为型模式 策略 观察者模式

# 单例模式
一个类只能有一个实例 并且可以在任意的地方访问到他
比如 Axios单例模式
    任务管理器
    回收站
    网站的计数器
    数据库连接池a

# JAVA设计模式
 - 先来看几个经典的面试题
   - 原型设计模式
   - 有请使用UML类图画出原型模式的核心角色
   - 原型设计模式的深拷贝和浅拷贝是什么? 并且画出深拷贝的两种方式的源码(重写clone方法 实现深拷贝 使用序列化来实现深拷贝)
   - 在Spring框架中 哪里使用了原型模式 并且对源码进行分析
     - beans.xml
     - <bean ud="id01" class="com.xx.spring.Test" scope="prototype" />
# 设计模式的七大原则 是什么 核心思想是什么 
   - 单一职责原则
   - 接口隔离原则
   - 依赖倒转原则
   - 里氏替换原则
   - 开闭原则
   - 迪米特原则
   - 合成复用原则

# 设计模式的重要性
软件工程中 设计模式 是对软件设计中普遍存在的问题 所提出的解决方案 
# 使用了设计模式后的优点
 - 可扩展性
 - 可维护性
 - 可读性
 - 
# 设计模式存在于软件的哪里
 软件体系
 语言 --> 功能模块[设计模式+算法(数据结构)] --> 框架[使用到多种的设计模式] -- > 架构[服务器集群]
 
# 授课方式
 应用场景 --> 设计模式 --> 剖析原理 --> 分析实现步骤 --> 代码实现 --> 框架或者源码分析

# 设计模式的目的
编写程序的过程中 程序员面临来自 耦合性 内聚性 以及可维护性 可扩展性 重用性 灵活性等多方面的挑战 设计模式就是为了解决这些

# 设计 设计模式的七大原则 详解
- 单一职责原则
  - 基本介绍
    - 对类来说的 即一个类 [应该只负责一项职责 例如订单类 就只负责订单的业务代码] 如果A负责两个不同职责 1 2 当职责1 变更需求而改变A时 可能会造成职责2错误 所以一个类就只需要负责一项职责 
    - 比如将A的粒度分解为 A1 A2
  - 应用案例
    - 交通工具的案例 SingleResponsebility类中
      - 有三种方案
        - 第一个类 就没有符合单一职责
        - 第二个类 通过降低类的粒度 来严格的遵守单一职责
        - 第三个类 通过只遵守方法级别的单一职责 
    - 单一职责原则的注意细节
      - 降低类的复杂度 一个类只负责一个职责
      - 提高类的可读性 可维护性
      - 降低变更引起的风险
      - 通常情况下 我们应该遵守单一职责原则 
        - 那些情况可以违背?
          - 只有逻辑足够简单 才可以在代码中违反单一职责原则 只有类中的方法足够少 可以在方法级别符合单一职责原则
- 接口隔离原则
  - 基本介绍
    - 客户端不应该依赖他不需要的接口 即一个类对另一个类的依赖 应该建立到最小的接口上
    - 比如 现在有 A B C D 四个类 并且有一个接口F内部有五个抽象方法
    - 这时 B 和 D 都去实现了这个接口中所有的方法 A这时想通过B使用接口的其中几个方法 但是B里面有接口的所有方法 所以违反了接口隔离原则 C D也是一样
    - 图解 ![img.png](img.png)
    - //按照依赖隔离原则 : 将接口拆分粒度 为几个独立的接口 类A 和 类C 分别使用对应的接口 这就是接口隔离
  - UML 图 [B D的线 是实现的意思 A C的线是依赖[通过接口来使用B D类 比如方法的数据类型为接口 但是传入的对象是B 也就是接口的实现类]]
    - 没有遵守的图例 
      - ![img_1.png](img_1.png)
    - 遵守的图例
      - ![img_3.png](img_3.png)
  - 小总结
    - 类A通过接口依赖B 类C通过接口依赖D 如果接口对于A 和C来说不是最小接口 那么就违背了接口隔离原则 必须要是最小接口单位
    - 客户端不应该依赖他不需要的接口 即一个类对另一个类的依赖应该建立在最小单位的接口上
- 依赖倒转原则 [面向接口编程]
  - 基本介绍
    - 高层的模块不应该依赖底层模块[Person类不能依赖一个微信 短信之类的类 而是应该依赖一个抽象的类 例如 信息(信息就是微信和短信的抽象)] 二者都应该依赖其抽象类[接口]
    - 抽象不应该存在依赖细节 细节应该依赖抽象
    - 依赖倒转的中心思想是面向接口编程 [抽象]
    - 使用接口或者抽象类的目的就是制作规范 而不涉及任何具体的操作 把展现细节的工作交给实现类来实现
  - 实现的方式
    - 通过接口传递来实现依赖
    - ![img_4.png](img_4.png)
    - 通过构造方法来依赖传递
    - ![img_5.png](img_5.png)
    - 通过setter方法来依赖传递
    - ![img_6.png](img_6.png)
    - 使用的方式
    - ![img_7.png](img_7.png)
    - 所以依赖倒置的三种方式 有 接口传递 构造函数传毒
  - 小总结
    - 低层模块最好都要有一个抽象类[比如ChangeHongTv SamSungTv AppleTv 这些都可以抽象为 Tv接口] 或者接口 或者两者都有 程序稳定性更好
    - 函数的参数量的声明类型最好是抽象类或者接口 这样我们的变量引用和实际对象之间 就存在一个缓冲层 利于程序的优化和扩展
  - 所以以后的设计应该是
    - 子类 ---实现---> 抽象类/接口 <--依赖/使用---- 功能模块 [功能模块通过使用接口 来使用这个接口的实现类]
- 里氏替换原则 [不要覆盖基类的方法]
  - 基础介绍
    - 为什么会有里氏替换? 他解决了什么问题
    - 面向对象中的继承问题
    - 1 继承包含这样一个含义 父类中凡是已经实现的方法 实际上是在设定规范和契约 虽然他不像接口一样必须要子类遵守 但是如果子类对这些已经实现的方法进行修改 就会对整个继承体系造成破坏
    - 2 继承在给程序设计带来便利时 也带来了弊端 比如使用继承会对程序带来侵入性[移植性降低] 增加对象的耦合度[比如父类如果要修改 要考虑所有的子类 并且修改后 还有可能子类会产生故障]
    - 里氏替换原则就是规定了 如何正确的使用继承关系
  - 里氏替换原则的思想
    - 比如T2继承T1 然后在程序中使用T1时 都可以将T1改为T2使用 并且不受影响 也就是 所有引用父类的地方都必须能够隐式的使用其子类的对象
    - 在使用继承时 一定也要遵循里氏替换原则 尽量子类不要去重写父类方法
    - 里氏替换告诉我们 继承实际上让两个类的耦合性增强了 [在适当的情况下 可以通过聚合 组合 依赖来解决问题]
    - 比如 B extends A 然后 A中有四个方法 但是B重写了A的所有方法 这样看来这个继承就是无意义的继承
  - 如何使用 
    - [使用 组合 聚合 依赖的方法 来避免继承关系]
- 开闭原则 [最重要的一个原则]
  - 基本介绍
    - 是编程中最基础 最重要的设计原则
    - 一个软件实体 如类 模块 函数应该 **对扩展开放[提供方]对修改关闭[使用方]**[即当我们给类增加新功能时 尽量不要修改代码 或者少修改代码] 用抽象实现框架 用实现扩展细节
    - 当软件需要变化时 尽量通过扩展软件实体的行为来实现变化 而不是通过修改已有的代码来实现变化
    - 编程中遵循其他的原则 以及使用设计模式的目的 就是为了遵循开闭原则
    
- 迪米特原则
  - 基本介绍
    - 一个对象一个对其他对象保持最小的了解
    - 类与类的关系越密切 耦合度越大
    - 迪米特法则 又叫最少知道法则 即一个类对自己的1依赖的类知道的越少越好 也就是说 对于被依赖的类不管多么复杂 都尽量封装在一个类中 出了对外的public方法 不泄露任何信息 
    - 迪米特法则还有一个 更简单的定义 只于直接的朋友联系
    - 直接的朋友?
      - 每个对象都会与其他对象有耦合关系 只要两个对象之间有耦合关系 我们就叫这种为朋友对象 耦合的方式有很多 聚合 依赖 组合 关联等 其中 我们称出现成员变量 方法参数 方法返回值中的类 为直接的朋友 
      - 而出现在局部变量中的对象 不是直接的朋友 也就是说 陌生的类 最好不要以局部变量的方式存在
    - 小总结
      - [迪米特法则就是 不要将自己的内部实现方法 写在别的类的内部！！]
      - 迪米特的核心是降低类与类的耦合度 但是不能消除耦合

- 合成复用原则
  - 基本介绍
    - 原则是尽量使用聚合 和 组成 而不是使用继承
    - 图解 ![img_8.png](img_8.png)

# 设计原则的核心思想
 1 找出应用中可能需要变化的地方 然后独立出来 不要和那些不需要变化的代码混合在一起[开闭原则 扩展开放(提供者) 修改关闭(使用者)]
 2 面向接口编程 而不是面向实现编程
 3 为了交互对象的松耦合设计而努力
 

# UML基本介绍
 - 关系介绍
   - Dependency
     - 依赖 也可以表示使用的意思
   - Association
     - 关联 1:N n:1 1:1 n:n
   - Generalization
     - 泛化 也就是继承
   - Realization 
     - 实现 
   - Aggregation
     - 聚合  例如A类 里面有一个成员变量的数据类型为B类 然后B类的值 是通过一个setter方法 进行赋值的 这时候 就表示A聚合B
   - Composite
     - 组合  例如A类 里面有一个成员变量的数据类型为B类 并且B类的值 直接赋值为 B b = new B(); 这时候就表示 A组合B类 这种耦合性要比聚合高
   

# 依赖 泛化 实现
 - 依赖 [泛化和是实现都是依赖关系]
   - 只要是在类中用到了其他类 那他们之间就存在依赖关系
   - 如 类的成员属性 类的返回值 类的参数类型 方法中使用到[可以是局部变量]
 - 泛化 
   - 也就是继承关系 A泛化B 就是 A继承B
 - 实现关系
   - 也就是一个类实现了接口 那么就是实现关系 A实现了B

# 关联 聚合 组合
 - 关联
   - 关联关系其实就是 类与类的关系 他是依赖关系的特里 关联具有导航型 如双向or单向
   - 关联具有多重型 如 1 表示有且只有一个 0... 表示0或者多个 0,1 表示0或者1个 n..m 表示n到m个都可以 m.. 表示至少m个
   - ![img_9.png](img_9.png)
 - 聚合关系
   - 聚合关系表示的是整体和部分的关系 整体和部分可以分开 聚合关系是关联关系的特例 所以它具有关联的导航性和多重性
   - 如 一台电脑 是由键盘 显示器 鼠标等组成 组成电脑的各个配件都是[可以分离]的 使用带空心菱形来表示
 - 组合关系
   - 组合关系和聚合关系的区别就是 一个可以分开 而组合关系不能分离
   - 图例 ![img_11.png](img_11.png)
# 设计模式
 - 设计模式的类型
   - ![img_12.png](img_12.png)

# 单例模式
 - 1 饿汉式 [静态常量]
   - 步骤
     - 构造器私有化 防止new
     - 类的内部创建对象
     - 向外暴露一个static方法 getInstance
   - 优缺点
     - 优点: 这种写法比较简单 并且在类加载classLoader阶段[因为是final static变量] 所以没有多线程问题
     - 缺点: 在类加载的时候就完成了实例化 没有达成lazy loading的效果 如果从始至终没有使用 那么会造成内存泄露 
   
 - 2 饿汉式 [静态代码块]
   - 步骤
     - 构造器私有化
     - 类的内部创建一个static成员变量 并且在静态代码块中进行创建单例对象
     - 向外暴露一个static方法 getInstance
   - 优缺点
     - 和上面静态常量的是一样的

 - 3 懒汉式 [懒加载 线程不安全]
   - 步骤
     - 构造器私有化
     - 创建一个静态的成员变量
     - 创建一个getInstance方法 在里面判断变量 ==null ? 赋值 return: return;
 - 4 懒汉式 [懒加载 线程安全 双重检查]
   - 步骤
     - 构造器私有化
     - 创建一个静态的成员变量
     - 创建一个getInstance方法 在里面判断变量 ==null 然后使用同步锁类.class 然后再次判断 ==null ? 赋值 ?return
   
 - 5 静态内部类
   - 先复习静态内部类的特点
     - 外部类装载时 静态内部类不会装载
     - 当调用里面的创建单例的方法时 会装载静态内部类 并且只会装载一次 并且classLoader是线程安全的
 - 6 枚举
   - 步骤
     - 创建一个枚举类
     - 然后添加一个枚举属性
     - 然后直接用    枚举类型 变量名 = 枚举类.枚举属性; 这样可以得到一个单例的枚举对象 并且可以解决反序列化的问题
     - Java作者推荐!!!

# 单例的使用事项
1 单例模式保证了 系统中这个类只存在一个实例化对象 节省了系统的资源 对于一些需要频繁创建销毁的对象 使用单例模式可以提高系统性能
2 想要实例化一个对象的时候 必须要记住使用相应的获取对象的方法 而不是使用new
3 单例的使用场景 需要频繁的进行创建和销毁的对象 创建对象时耗时过多或者耗费资源过多 (如 重量级对象) 但是又经常使用的对象 工具类对象(比如数据源 session工厂等等)

# 单例的所有类型
![img_13.png](img_13.png)


# 工厂模式
 - 简单工厂模式
   - 优点
   - 好理解 简单容易操作
   - 缺点是违反了OCP原则 即对扩展开放 修改关闭 即当我们给类新增一新功能时 尽量不要修改使用者的代码
   - ![img_14.png](img_14.png)
   - 基本介绍
   - 简单工厂模式属于创建者模式 是工厂模式的一种 简单工厂模式是由一个工厂对象来决定创建的产品类的实例 简单工厂是使用最多的工厂模式
   - 简单工厂模式 定义了一个创建对象的类 有这个类来封装实例化对象的行为
 - 工厂方法模式
   - 需求
   - ![img_15.png](img_15.png)
   - 基本介绍
   - 工厂方法模式就是 将一个项目的实例化功能抽象为一个抽象方法 在不同的子类中具体实现
   - 定义一个创建对象的抽象方法 由子类或者实现类来实现方法 并且指定要具体实例化的类 工厂方法模式将对象实例化 推迟到子类
   - ![img_16.png](img_16.png)
 - 抽象工厂模式
   - 抽象工厂模式 定义了一个 接口用于创建相关或者由依赖关系的对象组 而无需指名类 
   - 抽象工厂可以看作简单工厂 和 工厂方法的结合
   - 从设计上看就是上面两种的改进
   - 将工厂抽象为两层 一层为[抽象工厂] 和具体实现的工厂 程序员可以根据创建对象的类型使用相应的工厂子类 浙江将单个简单工厂变为了工厂组 更利于维护和扩展
 
# 工厂方法在 JDK源码中的使用
 - 简单工厂模式
 - ![img_17.png](img_17.png)
# 工厂模式的小姐
工厂模式的意义
    将实例化的代码 提取出来 放到一个类中统一管理和维护 达到和在项目的依赖关系的解耦从而提高扩展和维护性
三种工厂设计模式
    简单 工厂方法 抽象工厂
设计模式的
    依赖抽象原则【依赖倒转】

创建具体的对象实例时 不要直接new 要通过一个工厂的方法来创建
不要让类继承具体类 而是继承抽象类或者是实现接口
不要覆盖基类中已经实现的方法[里氏替换]


# 原型模式
 - 克隆羊问题
   - 现在有一只羊叫做tom 年龄为1 颜色为白色 请编写程序 创建和tom完全相同的10只羊
     - 代码
       `       
       //        创建十只羊
       //        传统方法
       //        优点 好理解 简单好操作
       //        缺点 在创建新的对象的时候 总是要获取原始对象的属性 如果创建的对象属性较多 效率会很低
       //        总是需要重新初始化对象 而不是动态的获取对象运行时的状态 不够灵活
       //        改进
       //        Java的Object中有一个clone方法 该方法可以将一个Java对象复制一份 但是需要实现clone的Java类 必须要实现一个接口Cloneable 该接口标识该类有能够复制且具有复制的能力 ==> 原型模式
       Sheep sheep= new Sheep(10,"tom","白色");
       Sheep sheep1 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
       Sheep sheep2 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
       Sheep sheep3 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
       Sheep sheep4 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
       Sheep sheep5 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
       Sheep sheep6 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
       Sheep sheep7 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
       Sheep sheep8 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
       Sheep sheep9 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());`
     
 - 基本介绍
   - 原型模式是指 用原型实例指定创建对象的种类 并且通过拷贝这些原型 创建新的对象
   - 原型模式是一种创建型的设计模式 允许一个对象 在创建另外一个可定制的对象无需知道如何创建的细节
   - 工作原理 通过将一个原型对象传给那个要发动创建的对象 这个要发动创建的对象通过请求原型对象来拷贝他们自己来实施创建 即 对象.clone()
   - 比喻 孙悟空拔出一根毛 变出很多个一样的孙悟空
 - UML原理图
 - ![img_18.png](img_18.png)
 - Prototype : 原型类 声明一个克隆自己的接口  
 - ConcreatePrototype 具体的实现类 实现一个克隆自己的操作
 - Client 让一个原型对象 克隆自己 从而创建一个新的对象

# 原型模式在Spring中的使用
    在beans中使用到了scope属性 中就可以指定为单例还是原型模式
    具体实现在ApplicationContext对象的getBean()方法中实现的
# 关于深拷贝对象中引用属性的处理方法
通过实验后 发现引用对象的属性 并不会深拷贝 只是都是指向同一个属性对象
 - 如何解决?
   - 深拷贝实现方法
   - 1 重写clone方法来实现deepClone
   - 2 通过对象的序列化来实现deepClone

# 浅拷贝 和 深拷贝
![img_19.png](img_19.png)