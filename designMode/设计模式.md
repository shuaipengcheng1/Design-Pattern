# 23种设计模式
创建型模式 单例模式(一个对象) 工厂模式(抽象工程模式) 建造者模式 原型模式
结构型模式 适配器模式(类似中间件)
行为型模式 策略 观察者模式

# 单例模式
一个类只能有一个实例 并且可以在任意的地方访问到他
比如 Axios单例模式
    任务管理器
    回收站
    网站的计数器
    数据库连接池

# JAVA设计模式
 - 先来看几个经典的面试题
   - 原型设计模式
   - 有请使用UML类图画出原型模式的核心角色
   - 原型设计模式的深拷贝和浅拷贝是什么? 并且画出深拷贝的两种方式的源码(重写clone方法 实现深拷贝 使用序列化来实现深拷贝)
   - 在Spring框架中 哪里使用了原型模式 并且对源码进行分析
     - beans.xml
     - <bean ud="id01" class="com.xx.spring.Test" scope="prototype" />
# 设计模式的七大原则 是什么 核心思想是什么 
   - 单一职责原则
   - 接口隔离原则
   - 依赖倒转原则
   - 里氏替换原则
   - 开闭原则
   - 迪米特原则
   - 合成复用原则

# 设计模式的重要性
软件工程中 设计模式 是对软件设计中普遍存在的问题 所提出的解决方案 
# 使用了设计模式后的优点
 - 可扩展性
 - 可维护性
 - 可读性
 - 
# 设计模式存在于软件的哪里
 软件体系
 语言 --> 功能模块[设计模式+算法(数据结构)] --> 框架[使用到多种的设计模式] -- > 架构[服务器集群]
 
# 授课方式
 应用场景 --> 设计模式 --> 剖析原理 --> 分析实现步骤 --> 代码实现 --> 框架或者源码分析

# 设计模式的目的
编写程序的过程中 程序员面临来自 耦合性 内聚性 以及可维护性 可扩展性 重用性 灵活性等多方面的挑战 设计模式就是为了解决这些

# 设计 设计模式的七大原则 详解
- 单一职责原则
  - 基本介绍
    - 对类来说的 即一个类 [应该只负责一项职责 例如订单类 就只负责订单的业务代码] 如果A负责两个不同职责 1 2 当职责1 变更需求而改变A时 可能会造成职责2错误 所以一个类就只需要负责一项职责 
    - 比如将A的粒度分解为 A1 A2
  - 应用案例
    - 交通工具的案例 SingleResponsebility类中
      - 有三种方案
        - 第一个类 就没有符合单一职责
        - 第二个类 通过降低类的粒度 来严格的遵守单一职责
        - 第三个类 通过只遵守方法级别的单一职责 
    - 单一职责原则的注意细节
      - 降低类的复杂度 一个类只负责一个职责
      - 提高类的可读性 可维护性
      - 降低变更引起的风险
      - 通常情况下 我们应该遵守单一职责原则 
        - 那些情况可以违背?
          - 只有逻辑足够简单 才可以在代码中违反单一职责原则 只有类中的方法足够少 可以在方法级别符合单一职责原则
- 接口隔离原则
  - 基本介绍
    - 客户端不应该依赖他不需要的接口 即一个类对另一个类的依赖 应该建立到最小的接口上
    - 比如 现在有 A B C D 四个类 并且有一个接口F内部有五个抽象方法
    - 这时 B 和 D 都去实现了这个接口中所有的方法 A这时想通过B使用接口的其中几个方法 但是B里面有接口的所有方法 所以违反了接口隔离原则 C D也是一样
    - 图解 ![img.png](img.png)
    - //按照依赖隔离原则 : 将接口拆分粒度 为几个独立的接口 类A 和 类C 分别使用对应的接口 这就是接口隔离
  - UML 图 [B D的线 是实现的意思 A C的线是依赖[通过接口来使用B D类 比如方法的数据类型为接口 但是传入的对象是B 也就是接口的实现类]]
    - 没有遵守的图例 
      - ![img_1.png](img_1.png)
    - 遵守的图例
      - ![img_3.png](img_3.png)
  - 小总结
    - 类A通过接口依赖B 类C通过接口依赖D 如果接口对于A 和C来说不是最小接口 那么就违背了接口隔离原则 必须要是最小接口单位
    - 客户端不应该依赖他不需要的接口 即一个类对另一个类的依赖应该建立在最小单位的接口上
- 依赖倒转原则
- 里氏替换原则
- 开闭原则
- 迪米特原则
- 合成复用原则
